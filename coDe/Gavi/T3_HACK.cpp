#include <iostream>

uint64_t _ALL_BITS[64] = {
    0b0000000000000000000000000000000000000000000000000000000000000001,
    0b0000000000000000000000000000000000000000000000000000000000000010,
    0b0000000000000000000000000000000000000000000000000000000000000100,
    0b0000000000000000000000000000000000000000000000000000000000001000,
    0b0000000000000000000000000000000000000000000000000000000000010000,
    0b0000000000000000000000000000000000000000000000000000000000100000,
    0b0000000000000000000000000000000000000000000000000000000001000000,
    0b0000000000000000000000000000000000000000000000000000000010000000,
    0b0000000000000000000000000000000000000000000000000000000100000000,
    0b0000000000000000000000000000000000000000000000000000001000000000,
    0b0000000000000000000000000000000000000000000000000000010000000000,
    0b0000000000000000000000000000000000000000000000000000100000000000,
    0b0000000000000000000000000000000000000000000000000001000000000000,
    0b0000000000000000000000000000000000000000000000000010000000000000,
    0b0000000000000000000000000000000000000000000000000100000000000000,
    0b0000000000000000000000000000000000000000000000001000000000000000,
    0b0000000000000000000000000000000000000000000000010000000000000000,
    0b0000000000000000000000000000000000000000000000100000000000000000,
    0b0000000000000000000000000000000000000000000001000000000000000000,
    0b0000000000000000000000000000000000000000000010000000000000000000,
    0b0000000000000000000000000000000000000000000100000000000000000000,
    0b0000000000000000000000000000000000000000001000000000000000000000,
    0b0000000000000000000000000000000000000000010000000000000000000000,
    0b0000000000000000000000000000000000000000100000000000000000000000,
    0b0000000000000000000000000000000000000001000000000000000000000000,
    0b0000000000000000000000000000000000000010000000000000000000000000,
    0b0000000000000000000000000000000000000100000000000000000000000000,
    0b0000000000000000000000000000000000001000000000000000000000000000,
    0b0000000000000000000000000000000000010000000000000000000000000000,
    0b0000000000000000000000000000000000100000000000000000000000000000,
    0b0000000000000000000000000000000001000000000000000000000000000000,
    0b0000000000000000000000000000000010000000000000000000000000000000,
    0b0000000000000000000000000000000100000000000000000000000000000000,
    0b0000000000000000000000000000001000000000000000000000000000000000,
    0b0000000000000000000000000000010000000000000000000000000000000000,
    0b0000000000000000000000000000100000000000000000000000000000000000,
    0b0000000000000000000000000001000000000000000000000000000000000000,
    0b0000000000000000000000000010000000000000000000000000000000000000,
    0b0000000000000000000000000100000000000000000000000000000000000000,
    0b0000000000000000000000001000000000000000000000000000000000000000,
    0b0000000000000000000000010000000000000000000000000000000000000000,
    0b0000000000000000000000100000000000000000000000000000000000000000,
    0b0000000000000000000001000000000000000000000000000000000000000000,
    0b0000000000000000000010000000000000000000000000000000000000000000,
    0b0000000000000000000100000000000000000000000000000000000000000000,
    0b0000000000000000001000000000000000000000000000000000000000000000,
    0b0000000000000000010000000000000000000000000000000000000000000000,
    0b0000000000000000100000000000000000000000000000000000000000000000,
    0b0000000000000001000000000000000000000000000000000000000000000000,
    0b0000000000000010000000000000000000000000000000000000000000000000,
    0b0000000000000100000000000000000000000000000000000000000000000000,
    0b0000000000001000000000000000000000000000000000000000000000000000,
    0b0000000000010000000000000000000000000000000000000000000000000000,
    0b0000000000100000000000000000000000000000000000000000000000000000,
    0b0000000001000000000000000000000000000000000000000000000000000000,
    0b0000000010000000000000000000000000000000000000000000000000000000,
    0b0000000100000000000000000000000000000000000000000000000000000000,
    0b0000001000000000000000000000000000000000000000000000000000000000,
    0b0000010000000000000000000000000000000000000000000000000000000000,
    0b0000100000000000000000000000000000000000000000000000000000000000,
    0b0001000000000000000000000000000000000000000000000000000000000000,
    0b0010000000000000000000000000000000000000000000000000000000000000,
    0b0100000000000000000000000000000000000000000000000000000000000000,
    0b1000000000000000000000000000000000000000000000000000000000000000
};
/**
 * WEIRD ASS CODE.... I worked my ass off without any reason.... :sad_emoji:
 * Gonna do re-write.... solution should be a Whole lot easier....
 *  
 * IF   X & N     isn't carbon copy.....
 *      FIND the first BIT that isnt COMMON in BOTH  - FIRST_UNMATCH
 *   if any BITS MATCH after FIRST_UNMATCH..... its not possible (print -1)
 * 
 * solution is as simple as that.....
 *  cz  M > N    
 *  now if    N = 101010101010
 *            M = 101011101010
 *            X = 101010000000          because   X = n & (n+1) & (n+2)   means 
 *     there is   101011000000          between N,M
 *                  
 */

static uint64_t n, x, ANSWER;

void print(uint64_t ANSWER, uint64_t T) {
    if ((T > 1800) && (T < 1860)) {
        if (ANSWER == 2) {
            std::cout << "x:"<<x<<"n:"<<n<<"ANSWER:"<<ANSWER<<"\n";
        }
    }
    else {
        if (ANSWER == 0) {
            std::cout << "-1" << std::endl;
        }
        else {
            std::cout << ANSWER << std::endl;
        }
    }
}


void solveCase(int t) {
    std::cin >> n >> x;

         if (x == n) print( x, t);
    else if (x  > n) print(0, t);
    else {
        uint64_t BITS_WorkArea = 0; uint32_t left = 0, right = 0; uint32_t x_first_bit_found = 1, n_in_a_streak = 0, last_x = 0; uint32_t notOk = 0, STATE = 1; uint32_t i = 63;

        if      (n <= _ALL_BITS[15]) i = 15;
        else if (n <= _ALL_BITS[31]) i = 31;
        else if (n <= _ALL_BITS[47]) i = 47;

        while (i--) {
            if (n & _ALL_BITS[i]) {                
                left = i;

                if ((x & _ALL_BITS[i]) == 0) {
                    if (x == 0) {print(_ALL_BITS[left+1], t); return;}
                }
                else
                    last_x = 0;

                break;
            }
        }




        for (int I = left, LIM = right; I >= LIM; I--) {
            // Variable to Optimize IG....
            uint64_t uhhhhh = n & _ALL_BITS[I];
            uint64_t x_mask = x & _ALL_BITS[I];

            
            // TO TRACK whats after STATE_2
            if (STATE == 2) {
                 if (x_mask & uhhhhh)       STATE = 1;
            else if((x_mask & uhhhhh) == 0) STATE = 0;
            }

            if (notOk && (x & _ALL_BITS[I])) {
                print(0, t);return;
            }


            // LOGICAL-& operator not BITWISE!!!!
            if ((!x_first_bit_found) && x_mask) x_first_bit_found = I;
            // IF X's BIT isnt there but n has it
            else if (x_mask < uhhhhh) {
                if  (notOk && (STATE == 1)) {       // we've occured on a STATE_1   (both x & n = 1) after STATE 2
                    print(0, t);return;
                }
                else if ((I+n_in_a_streak) == left) {
                    // if this is the case.... this means that e.g. n = 1100, x = 1000      in this case you can't find    m > n
                    print(0, t);return;
                }
                else if (notOk == 0) {
                    notOk = I+n_in_a_streak+1; STATE = 2;

                    if (last_x <= ((I+n_in_a_streak))) {
                    print(0, t);return;
                    }
                }
                // We'll only pass if the rest of the BITS [to the right, in N (& also in X)] is also ZERO
            }
            // Check if 'x' has any BITS turned ON that 'n' doesn't
            else if (x_mask > uhhhhh) { 
                    print(0, t);return;
            }


            if (uhhhhh)
                n_in_a_streak++;
            else
                n_in_a_streak = 0;

            if (x_mask)
                last_x = I;

            //std::cout << "x_Mask:" << x_mask << " uhhhhh:" << uhhhhh <<" x:"<<x<<" n:"<<n << " notOk:" << notOk << std::endl;
        }



        uint64_t ZERO = 0;
        if          (n == 1) {
            if      (x  > 1) {print(0, t);return;}
            else if (x == 1) {print( 1, t);return;} 
            else if (x == 0) {print( 2, t);return;}
        }
        else if     (x == 0) {/** std::cout << _ALL_BITS[left+1] << "\n"; return;*/  print(_ALL_BITS[left+1], t); return;}
        else if     ((x & _ALL_BITS[0]) == 1) {
                              print(0, t);return;   /** Well, only way this could have worked if   n == x   .... but we checkd that already before....*/
        }
        else {
            //std::cout << (_ALL_BITS[notOk] | x) << "\n";
            print((_ALL_BITS[notOk] | x), t); return;
        }

        /**
        if ((n >> (left-1)) == 1) {        //  000110010 .... then 'm' has to be at least `001000000`
            std::cout << (_ALL_BITS[left+1] | x) << "\n";
        }
        else {
            std::cout << (_ALL_BITS[left-1] | x) << "\n";
        }
        */
    }
}

int main(void) {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    uint32_t nCases;
    std::cin >> nCases;

    for (uint32_t i = 0; i < nCases; i++) {
        solveCase(i);
    }
}